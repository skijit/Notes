MongoDB Intro
=================

- [src1](https://www.youtube.com/watch?v=pWbMrx5rVBE)
- document database
- big advantage over relational: easy to scale
- installation for windows:
    - download
    - chooses a custom install target folder    
    - create additional folders in install target:
        - data
            - db
        - log
    - open up cmd.exe w/ admin permissions
        - navigate to the bin folder
        - `mongod --directoryperdb --dbpath C:\path-to-the-db-directory --logpath C:\path-to-the-log-dir\mongo.log --logappend --rest --install`
            - this allows us to run it as a service
        - `net start MongoDb`
            - this starts the service running
    - You can start the mongo shell by going to the bin directory and executing `mongo`
- Mongo shell commands
    - `cls` will clear everything
    - `show dbs` will show you the list dbs (don't touch the local)
    - `use mycustomers` will create a db called 'mycustomers' and switch you to using it
    - `db` will tell you what database you're currently using
- Dealing with records
    - arrays
    - strings
    - objects

```(javascript)
{
    firstName: "John",
    lastName: "Doe",
    memberships: ["mem1", "mem2"],
    address: {
        street: "blah blah"
        city: "Las Whateverus"
    },
    contacts: [
        { name: "Brad", relationship: friend}
    ]

}
```

- Creating users

```(javascript)
db.createUser({
    user: "Brad",
    pwd: "1234",
    roles: ["readWrite", "dbAdmin"]
})
```

    - see the [docs.mongodb.com](https://docs.mongodb.com/manual/reference/method/db.createUser/index.html) for info on how to use this

- Add a collection (like a table)
    - `db.createCollection('customers');`
    - `show collections` to see the various collections in the current db
    - `db.customers.insert({first_name: "John", last_name: "Smith"}); ` to add a record to a collection
        - you could also insert records with an array as a parameter
        - notice you're schema free, some records can have different fields
    - `db.customers.find();` will show you all the records in the collection
        - each record will have an autogenerated `_id` field
    - `db.customers.find().pretty();` will pretty-print the output
- Updating records
    - `db.customers.update({first_name:"John"}, {first_name:"John", last_name:"Doe", gender: "M" })`
        - first parameter identifies the records you want to update
        - second parameter tells you the fields 
            - in this case, the corresponding record(s) and all it's fields will be overwritten with whatever is in the 2nd parameter.
            - if you want to only affect some of the fields, you can use set operator...
    - $set operator:
        - `db.customers.update({first_name:"John"},{$set:{gender:"male"}})`
            - so this will only update the 'gender' field
    - $inc operator:
        - `db.customers.update({first_name:"John"}, {$inc:{age:5}})`
        - will increment the age by 5
    - $unset operator:
        - `db.customers.update({first_name:"John"}, {$unset:{age:1}}`
        - this will remove the field entirely
    - updating something that isn't there:
        - if the first parm in `update()` doesn't match anything, no changes are made
        - but you can upsert by specifying a third parameter:
            - `db.customers.update({first_name:"Mary"}, {$set:{last_name:"Jones"}}, { upsert: true})`
    - $rename operator:
        -  `db.customers.update({first_name:"Mary"}, {$rename:"gender":"sex"});
        - will change the name of the field
- Removing records
    - `db.customers.remove({first_name:"Steven"})`
        - will delete any matchin records in the collection
    - `db.customers.remove({first_name:"Steven"}, {justOne:true})`
        - will only remove the first match
- Querying
    - `db.customers.find({first_name:"Sharon"})`
    - `db.customers.find({$or: [{first_name:"Sharon"},{first_name:"Troy"}]})`
        - $or operator
    - `db.customers.find({age:{$lt:40}})`
        - there are $lt, $lte, $gte, and $gt operators
    - `db.customers.find({"address.city":"Boston"})`
        - address.city is wrapped in quotes because you're dealing with nested objects now
        - in general, wrapping the fields in quotes is ok too
- Sorting
    - `db.customers.find().sort({last_name:1})`
        - the 1 means ascending order
        - for descending order, use -1
- Counting
    - `db.customers.find().count()`
- Limiting / Take
    - `db.customers.find().limit(4)`
- Iterating
    - `db.customers.find().forEach(function(doc){ print("Customer Name:" + doc.first_name)})`

## Another source
- [src](https://www.youtube.com/watch?v=UFVFIKduXpo)
- see cap triangle
- you can index on field(s)
    - if you want to shard, this is index-based
- hierarchy
    - databases
    - collections
    - documents
- you can't reference collections across databases
- architecture
    - replication sets
        - you have one single master database instance which can then replicate transactions via it's operation log to any number of secondary db instances
        - those db instances could be operational OR they could be used for backup (basically- this is about durability, not scaling)
        - if the primary/master instance goes down, the secondaries will choose another secondary as the de facto primary
            - then when the original primary comes back up, the operation logs can be applied to it to get it up to date.
        - quirks:
            - a majority of the servers in your set must agree on the primary
            - meaning: you need at least 3 servers if you do replication
                - or you can set up an 'arbiter' node which will decide which to use.
            - apps need to know who is the primary or secondary and be able to failover
            - delayed secondaries can be set up as insurance against accidental mistakes
     - sharding
        - application server will talk to a proces called 'mongos'
        - mongos talks to one of 3 different config servers which analyze the operation to figure out which primary instance you should talk with
        - there will be X multiple primary instances, each dividing a collection into groups (shards) based on the value of some indexed field(s)
        - each primary still will have its own sets of secondaries
        - mongos runs a balancer, so it can rebalance your shards in real-time if things are not evenly distributed
        - quirks:
            - auto-sharding sometimes fails
                - split storms: can't reshard the data
                - mongos processes restarted too often
            - you need 3 config servers
                - if one goes down, your DB is down
            - mongodb's loose document model can be att odds with effective sharding
- supports many indices
    - only 1 can be used for sharding
    - more than 2-3 are discouraged
    - full text indices for text searches
    - spatial indices
- built in aggregation capabilities
    - you can run MapReduce (going into Hadoop territory)
    - Has it's own file system GridFS
    - Integrates with Hadoop, Spark, and most languages

## Another Source
- [src](https://www.youtube.com/watch?v=bKjH8WhSu_E)
- `db.users.insertOne({object})`

## Installing on OSX
- [src](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/)
- to spin up mongo: `mongod`
    - press Ctrl-C to end
- to connect to mongo: `mongo --host 127.0.0.1:27017` with whatever port the other terminal said it was connected as

## Connecting via the DotNet Driver
- [blog post](http://www.qappdesign.com/using-mongodb-with-net-core-webapi/)
- [nuget package page](https://mongodb.github.io/mongo-csharp-driver/)
    - [reference for current version (2.7)](https://mongodb.github.io/mongo-csharp-driver/2.7/)
        - the quick start guide is concise and very good
- Your appsettings.json file will include your connection string
    - The blog post has details about how you can DI those settings rather than just read them from your config (see for more info)
- use nuget package: MongoDB.Driver
- You define POCOs to represent the documents in the DB

```(csharp)
using System;
using MongoDB.Bson.Serialization.Attributes;

namespace NotebookAppApi.Model
{
    public class Note
    {
        [BsonId]
        // standard BSonId generated by MongoDb
        public ObjectId InternalId { get; set; }                

        // external ID or key, which may be easier to reference (ex: 1,2,3 etc.)
        public string Id { get; set; }                           

        public string Body { get; set; } = string.Empty;
        public DateTime UpdatedOn { get; set; } = DateTime.Now;
        public DateTime CreatedOn { get; set; } = DateTime.Now;
        public int UserId { get; set; } = 0;
    }
}
```

- Blog post architecture...
    - defines a *Context* class which holds:
        - a ref to the db
        - returns each collection<T> for the pocos
    - Context class also has the connection string info DI'ed in
    - There's a repository classes that has actions for all the CRUD
        - repository has a private context class
        - All CRUD methods involve an async call, either in the driver method, or how they're materialized (e.g. ToListAsync())
    - For DI purposes, the Repository is defined as a transient
    - All Web API Get actions have the NoCache attribute to make sure there's no client caching
    - All Web API action methods are also async
    - Remember to look into Model Binding in the Web API methods
    

- TODO:
    - review the CRUD functions in the blogpost













